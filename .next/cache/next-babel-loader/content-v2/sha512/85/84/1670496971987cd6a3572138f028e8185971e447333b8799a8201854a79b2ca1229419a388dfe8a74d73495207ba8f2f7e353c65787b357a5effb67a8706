{"ast":null,"code":"import connect from 'next-connect';\nimport { Ticket } from '@typeDefs/ticket';\nimport rawReports from '@data/reports.json';\nlet reports = rawReports.elements.map(({\n  id,\n  state,\n  payload\n}) => {\n  var _payload$message;\n\n  return new Ticket(id, payload.reportType, state, (_payload$message = payload.message) !== null && _payload$message !== void 0 ? _payload$message : '');\n});\nconst handler = connect();\nhandler.get('/', async ({}, res) => {\n  try {\n    const active = reports.filter(report => report.status === 'OPEN');\n    res.status(200).json({\n      reports: {\n        active\n      }\n    });\n  } catch (err) {\n    throw new Error(err);\n  }\n\n  ;\n});\nhandler.get('/resolved', async ({}, res) => {\n  try {\n    const resolved = reports.filter(report => report.status === 'RESOLVED');\n    res.status(200).json({\n      reports: {\n        resolved\n      }\n    });\n  } catch (err) {\n    throw new Error(err);\n  }\n\n  ;\n});\nhandler.get('/blocked', async ({}, res) => {\n  try {\n    const blocked = reports.filter(report => report.status === 'BLOCKED');\n    res.status(200).json({\n      reports: {\n        blocked\n      }\n    });\n  } catch (err) {\n    throw new Error(err);\n  }\n\n  ;\n});\nhandler.put('/:reportId', async (req, res) => {\n  try {\n    if (!req.query.param) {\n      return res.status(304).json({\n        error: 'Empty reportId param'\n      });\n    }\n\n    const {\n      reportId\n    } = req.query;\n    reports = reports.map(item => {\n      if (item.id === reportId) {\n        item.status === req.body.ticketState;\n      }\n\n      return item;\n    });\n    reports = reports.filter(item => item.id !== reportId);\n    res.status(200).json({\n      reports\n    });\n  } catch (err) {\n    throw new Error(err);\n  }\n\n  ;\n});\nexport const config = {\n  api: {\n    bodyParser: false // Disallow body parsing, consume as stream\n\n  }\n};\nexport default handler;","map":{"version":3,"sources":["/Users/kodeemcintosh/Repos/coding-challenge/pages/api/reports.tsx"],"names":["connect","Ticket","rawReports","reports","elements","map","id","state","payload","reportType","message","handler","get","res","active","filter","report","status","json","err","Error","resolved","blocked","put","req","query","param","error","reportId","item","body","ticketState","config","api","bodyParser"],"mappings":"AAEA,OAAOA,OAAP,MAAoB,cAApB;AAEA,SAASC,MAAT,QAAuB,kBAAvB;AACA,OAAOC,UAAP,MAAuB,oBAAvB;AAEA,IAAIC,OAAiB,GAAGD,UAAU,CAACE,QAAX,CAAoBC,GAApB,CAAwB,CAAC;AAAEC,EAAAA,EAAF;AAAMC,EAAAA,KAAN;AAAaC,EAAAA;AAAb,CAAD,KAA2B;AAAA;;AACvE,SAAO,IAAIP,MAAJ,CAAWK,EAAX,EAAeE,OAAO,CAACC,UAAvB,EAAmCF,KAAnC,sBAA0CC,OAAO,CAACE,OAAlD,+DAA6D,EAA7D,CAAP;AACD,CAFqB,CAAxB;AAIA,MAAMC,OAAO,GAAGX,OAAO,EAAvB;AAEAW,OAAO,CAACC,GAAR,CAAY,GAAZ,EAAiB,OAAO,EAAP,EAAWC,GAAX,KAAmB;AAClC,MAAI;AACF,UAAMC,MAAM,GAAGX,OAAO,CAACY,MAAR,CAAgBC,MAAD,IAAYA,MAAM,CAACC,MAAP,KAAkB,MAA7C,CAAf;AAEAJ,IAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEf,MAAAA,OAAO,EAAE;AAAEW,QAAAA;AAAF;AAAX,KAArB;AACD,GAJD,CAIE,OAAMK,GAAN,EAAW;AACX,UAAM,IAAIC,KAAJ,CAAUD,GAAV,CAAN;AACD;;AAAA;AACF,CARD;AAUAR,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyB,OAAO,EAAP,EAAWC,GAAX,KAAmB;AAC1C,MAAI;AACF,UAAMQ,QAAQ,GAAGlB,OAAO,CAACY,MAAR,CAAgBC,MAAD,IAAYA,MAAM,CAACC,MAAP,KAAkB,UAA7C,CAAjB;AAEAJ,IAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEf,MAAAA,OAAO,EAAE;AAAEkB,QAAAA;AAAF;AAAX,KAArB;AACD,GAJD,CAIE,OAAMF,GAAN,EAAW;AACX,UAAM,IAAIC,KAAJ,CAAUD,GAAV,CAAN;AACD;;AAAA;AACF,CARD;AAUAR,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwB,OAAO,EAAP,EAAWC,GAAX,KAAmB;AACzC,MAAI;AACF,UAAMS,OAAO,GAAGnB,OAAO,CAACY,MAAR,CAAgBC,MAAD,IAAYA,MAAM,CAACC,MAAP,KAAkB,SAA7C,CAAhB;AAEAJ,IAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEf,MAAAA,OAAO,EAAE;AAAEmB,QAAAA;AAAF;AAAX,KAArB;AACD,GAJD,CAIE,OAAMH,GAAN,EAAW;AACX,UAAM,IAAIC,KAAJ,CAAUD,GAAV,CAAN;AACD;;AAAA;AACF,CARD;AAUAR,OAAO,CAACY,GAAR,CAAY,YAAZ,EAA0B,OAAOC,GAAP,EAAYX,GAAZ,KAAoB;AAC5C,MAAI;AACF,QAAG,CAACW,GAAG,CAACC,KAAJ,CAAUC,KAAd,EAAqB;AACnB,aAAOb,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAES,QAAAA,KAAK,EAAE;AAAT,OAArB,CAAP;AACD;;AAED,UAAM;AAAEC,MAAAA;AAAF,QAAeJ,GAAG,CAACC,KAAzB;AACAtB,IAAAA,OAAO,GAAGA,OAAO,CAACE,GAAR,CAAawB,IAAD,IAAU;AAC9B,UAAGA,IAAI,CAACvB,EAAL,KAAYsB,QAAf,EAAyB;AACvBC,QAAAA,IAAI,CAACZ,MAAL,KAAgBO,GAAG,CAACM,IAAJ,CAASC,WAAzB;AACD;;AAED,aAAOF,IAAP;AACD,KANS,CAAV;AAQA1B,IAAAA,OAAO,GAAGA,OAAO,CAACY,MAAR,CAAgBc,IAAD,IAAUA,IAAI,CAACvB,EAAL,KAAYsB,QAArC,CAAV;AACAf,IAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEf,MAAAA;AAAF,KAArB;AACD,GAhBD,CAgBE,OAAMgB,GAAN,EAAW;AACX,UAAM,IAAIC,KAAJ,CAAUD,GAAV,CAAN;AACD;;AAAA;AACF,CApBD;AAsBA,OAAO,MAAMa,MAAM,GAAG;AACpBC,EAAAA,GAAG,EAAE;AACHC,IAAAA,UAAU,EAAE,KADT,CACgB;;AADhB;AADe,CAAf;AAMP,eAAevB,OAAf","sourcesContent":["\nimport { NextApiRequest, NextApiResponse } from \"next\";\nimport connect from 'next-connect';\n\nimport { Ticket } from '@typeDefs/ticket';\nimport rawReports from '@data/reports.json';\n\nlet reports: Ticket[] = rawReports.elements.map(({ id, state, payload}) => {\n    return new Ticket(id, payload.reportType, state, payload.message ?? '');\n  });\n\nconst handler = connect<NextApiRequest, NextApiResponse>();\n\nhandler.get('/', async ({}, res) => {\n  try {\n    const active = reports.filter((report) => report.status === 'OPEN');\n\n    res.status(200).json({ reports: { active } });\n  } catch(err) {\n    throw new Error(err);\n  };\n});\n\nhandler.get('/resolved', async ({}, res) => {\n  try {\n    const resolved = reports.filter((report) => report.status === 'RESOLVED');\n\n    res.status(200).json({ reports: { resolved } });\n  } catch(err) {\n    throw new Error(err);\n  };\n});\n\nhandler.get('/blocked', async ({}, res) => {\n  try {\n    const blocked = reports.filter((report) => report.status === 'BLOCKED');\n\n    res.status(200).json({ reports: { blocked } });\n  } catch(err) {\n    throw new Error(err);\n  };\n});\n\nhandler.put('/:reportId', async (req, res) => {\n  try {\n    if(!req.query.param) {\n      return res.status(304).json({ error: 'Empty reportId param' });\n    }\n\n    const { reportId } = req.query;\n    reports = reports.map((item) => {\n      if(item.id === reportId) {\n        item.status === req.body.ticketState;\n      }\n\n      return item;\n    });\n\n    reports = reports.filter((item) => item.id !== reportId);\n    res.status(200).json({ reports });\n  } catch(err) {\n    throw new Error(err);\n  };\n});\n\nexport const config = {\n  api: {\n    bodyParser: false, // Disallow body parsing, consume as stream\n  },\n};\n\nexport default handler;"]},"metadata":{},"sourceType":"module"}